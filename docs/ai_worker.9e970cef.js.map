{"mappings":"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","sources":["src/connect_four.ts","src/ai_worker.ts"],"sourcesContent":["import { number } from \"prop-types\";\r\n\r\nexport type Tile = 'EMPTY' | 'PLAYER_1' | 'PLAYER_2';\r\nexport type GameState = 'PLAYER_1_TURN' | 'PLAYER_2_TURN' | 'PLAYER_1_WIN' | 'PLAYER_2_WIN' | 'DRAW';\r\n\r\nexport const Constants = {\r\n    COLUMNS: 7,\r\n    ROWS: 6,\r\n    ALL_COLUMNS_INDICES: [0, 1, 2, 3, 4, 5, 6],\r\n    ALL_ROW_INDICES: [0, 1, 2, 3, 4, 5],\r\n    TURN_TO_TILE_MAP: {\r\n        'PLAYER_1_TURN': 'PLAYER_1',\r\n        'PLAYER_2_TURN': 'PLAYER_2'\r\n    }\r\n}\r\n\r\nexport class ConnectFourGame {\r\n    board: Tile[][];\r\n    gameState: GameState;\r\n    moveHistory: number[];\r\n    gameStateHistory: GameState[];\r\n\r\n    constructor() {\r\n        this.board = [\r\n            ['EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY'],\r\n            ['EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY'],\r\n            ['EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY'],\r\n            ['EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY'],\r\n            ['EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY'],\r\n            ['EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY'],\r\n        ];\r\n        this.gameState = 'PLAYER_1_TURN';\r\n        this.moveHistory = [];\r\n        this.gameStateHistory = ['PLAYER_1_TURN'];\r\n    }\r\n\r\n    isOver() {\r\n        return this.gameState != 'PLAYER_1_TURN' && this.gameState != 'PLAYER_2_TURN';\r\n    }\r\n\r\n    moveIsValid(column: number) {\r\n        return this.board[Constants.ROWS - 1][column] == 'EMPTY';\r\n    }\r\n\r\n    validMoves() {\r\n        return Constants.ALL_COLUMNS_INDICES.filter(column => this.moveIsValid(column));\r\n    }\r\n\r\n    currentPlayer(): 'PLAYER_1' | 'PLAYER_2' {\r\n        if (this.gameStateHistory.length === 1) {\r\n            return 'PLAYER_1';\r\n        }\r\n        \r\n        const previousGameState = this.gameStateHistory[this.gameState.length - 2];\r\n        if (previousGameState === 'PLAYER_1_TURN') {\r\n            return 'PLAYER_2';\r\n        } else if (previousGameState === 'PLAYER_2_TURN') {\r\n            return 'PLAYER_1';\r\n        }\r\n    }\r\n\r\n    playerHasWon(player: 'PLAYER_1' | 'PLAYER_2') {\r\n        if (this.gameState === 'PLAYER_1_WIN' && player === 'PLAYER_1') {\r\n            return true;\r\n        } else if (this.gameState === 'PLAYER_2_WIN' && player === 'PLAYER_2') {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    push(column: number) {\r\n        if (this.isOver()) {\r\n            throw new Error(\"Invalid move. Game is already over.\");\r\n        }\r\n\r\n\r\n        if (!this.moveIsValid(column)) {\r\n            throw new Error(\"Invalid move. Column is filled.\");\r\n        }\r\n\r\n        const rowToFill = Math.min(...Constants.ALL_ROW_INDICES.filter(row => this.board[row][column] == 'EMPTY'));\r\n\r\n        this.board[rowToFill][column] = Constants.TURN_TO_TILE_MAP[this.gameState];\r\n\r\n        const updatedGameState = this._calculateUpdatedGameState(rowToFill, column);\r\n        this.gameState = updatedGameState;\r\n\r\n        this.moveHistory.push(column);\r\n        this.gameStateHistory.push(updatedGameState);\r\n    }\r\n\r\n    pop() {\r\n        if (this.moveHistory.length === 0) {\r\n            throw new Error(\"Can't undo. No move to undo.\");\r\n        }\r\n\r\n        const column = this.moveHistory.pop();\r\n        this.gameStateHistory.pop();\r\n        const previousGameState = this.gameStateHistory[this.gameStateHistory.length - 1];\r\n        \r\n        const rowToClear = Math.max(...Constants.ALL_ROW_INDICES.filter(row => this.board[row][column] != 'EMPTY'));\r\n\r\n        this.board[rowToClear][column] = 'EMPTY';\r\n        this.gameState = previousGameState;\r\n    }\r\n\r\n    _calculateUpdatedGameState(changedRow: number, changedColumn: number): GameState {\r\n        //  Check column for victory\r\n        const findFourInARow = (tiles: Tile[]): undefined | 'PLAYER_1_WIN' | 'PLAYER_2_WIN' => {\r\n            var consecutiveTile: Tile = 'EMPTY';\r\n            var consecutiveCount = 0;\r\n            for (var i = 0; i < tiles.length; i++) {\r\n                if (tiles[i] === consecutiveTile) {\r\n                    consecutiveCount += 1;\r\n                } else {\r\n                    consecutiveTile = tiles[i];\r\n                    consecutiveCount = 1;\r\n                }\r\n\r\n                if (consecutiveCount === 4 && consecutiveTile !== 'EMPTY') {\r\n                    if (consecutiveTile === 'PLAYER_1') {\r\n                        return 'PLAYER_1_WIN';\r\n                    } else {\r\n                        return 'PLAYER_2_WIN';\r\n                    }\r\n                }\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        const columnTiles = Constants.ALL_ROW_INDICES.map(row => this.board[row][changedColumn]);\r\n        const columnFourInARow = findFourInARow(columnTiles);\r\n        if (columnFourInARow) {\r\n            return columnFourInARow;\r\n        }\r\n\r\n        const rowTiles = Constants.ALL_COLUMNS_INDICES.map(column => this.board[changedRow][column]);\r\n        const rowFourInARow = findFourInARow(rowTiles);\r\n        if (rowFourInARow) {\r\n            return rowFourInARow;\r\n        }\r\n\r\n        // Up-right diagonal\r\n        var delta = Math.min(changedRow, changedColumn);\r\n        var columnIndex = changedColumn - delta;\r\n        var rowIndex = changedRow - delta;\r\n        const upRightDiagonalTiles = [];\r\n        while (columnIndex < Constants.COLUMNS && rowIndex < Constants.ROWS) {\r\n            upRightDiagonalTiles.push(this.board[rowIndex][columnIndex]);\r\n            columnIndex += 1;\r\n            rowIndex += 1;\r\n        }\r\n        const upDiagonalFourInARow = findFourInARow(upRightDiagonalTiles);\r\n        if (upDiagonalFourInARow) {\r\n            return upDiagonalFourInARow;\r\n        }\r\n\r\n        // # Up-left\r\n        delta = Math.min(Constants.COLUMNS - changedColumn, changedRow);\r\n        columnIndex = changedColumn + delta;\r\n        rowIndex = changedRow - delta;\r\n        const upLeftDiagonalTiles = []\r\n        while (columnIndex >= 0 && rowIndex < Constants.ROWS) {\r\n            upLeftDiagonalTiles.push(this.board[rowIndex][columnIndex]);\r\n            columnIndex -= 1;\r\n            rowIndex += 1;\r\n        }\r\n        const upLeftDiagonalFourInARow = findFourInARow(upLeftDiagonalTiles);\r\n        if (upLeftDiagonalFourInARow) {\r\n            return upLeftDiagonalFourInARow;\r\n        }\r\n\r\n        if (this.validMoves().length == 0) {\r\n            return 'DRAW';\r\n        }\r\n\r\n        if (this.gameState === 'PLAYER_1_TURN') {\r\n            return 'PLAYER_2_TURN';\r\n        } else {\r\n            return 'PLAYER_1_TURN';\r\n        }\r\n    }\r\n}","import { ConnectFourGame, Constants } from \"./connect_four\";\r\n\r\nclass MCTS {\r\n    game: ConnectFourGame\r\n    root: MCTSNode\r\n\r\n    constructor(game: ConnectFourGame) {\r\n        this.game = game;\r\n        this.root = new MCTSNode(game.validMoves(), undefined);\r\n    }\r\n\r\n    search(): number | undefined {\r\n        if (this.game.isOver()) {\r\n            return undefined;\r\n        }\r\n\r\n        var totalIterations = 0;\r\n        const start = performance.now();\r\n        const computationTime = 1 * 1000; // 1 second\r\n        while (performance.now() - start < computationTime) {\r\n            for (var i = 0; i < 2000; i++) {\r\n                this.root._search(this.game, findCurrentTargetState(this.game));\r\n            }\r\n            totalIterations += 2000;\r\n        }\r\n\r\n        console.log(totalIterations)\r\n        return this.root.expSelectMove();\r\n    }\r\n}\r\n\r\nfunction findCurrentTargetState(game: ConnectFourGame): 'PLAYER_1_WIN' | 'PLAYER_2_WIN' {\r\n    if (game.gameState === 'PLAYER_1_TURN') {\r\n        return 'PLAYER_1_WIN';\r\n    } else if (game.gameState === 'PLAYER_2_TURN') {\r\n        return 'PLAYER_2_WIN';\r\n    } else {\r\n        throw new Error('Unexpected conditions');\r\n    }\r\n}\r\n\r\nfunction randomPlaythrough(game: ConnectFourGame): 'PLAYER_1_WIN' | 'PLAYER_2_WIN' | 'DRAW' {\r\n    var moveCount = 0;\r\n    while (!game.isOver()) {\r\n        const validMoves = game.validMoves();\r\n        const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];\r\n        game.push(randomMove);\r\n        moveCount += 1;\r\n    }\r\n\r\n    const result = game.gameState as 'PLAYER_1_WIN' | 'PLAYER_2_WIN' | 'DRAW';\r\n    for (var i = 0; i < moveCount; i++) {\r\n        game.pop();\r\n    }\r\n    return result;\r\n}\r\n\r\nclass MCTSNode {\r\n    move: number\r\n    wins: number\r\n    n: number\r\n    validMoves: number[]\r\n    moveToChildMap: MCTSNode[]\r\n\r\n    constructor(validMoves: number[], move: number) {\r\n        this.move = move;\r\n        this.wins = 0;\r\n        this.n = 0;\r\n        this.validMoves = validMoves;\r\n        this.moveToChildMap = [];\r\n    }\r\n\r\n    search(game: ConnectFourGame): 'PLAYER_1_WIN' | 'PLAYER_2_WIN' | 'DRAW' {\r\n        const targetState = findCurrentTargetState(game);\r\n\r\n        game.push(this.move);\r\n        const searchResult = this._search(game, targetState);\r\n        game.pop();\r\n\r\n        return searchResult;\r\n    }\r\n\r\n    getMoveChildPairs(): [number, MCTSNode | undefined][] {\r\n        return this.validMoves.map(move => [move, this.moveToChildMap[move]]);\r\n    }\r\n\r\n    ucbSelectMove(): number {\r\n        const c = Math.sqrt(2);\r\n        var bestMove: number = undefined;\r\n        var bestMoveScore: number = -Infinity;\r\n        for (const [move, child] of this.getMoveChildPairs()) {\r\n            if (!child) {\r\n                return move;\r\n            }\r\n            const score = (child.wins / child.n) + c * Math.sqrt(Math.log(this.n) / child.n);\r\n            if (score > bestMoveScore) {\r\n                bestMove = move;\r\n                bestMoveScore = score;\r\n            }\r\n        }\r\n\r\n        return bestMove;\r\n    }\r\n\r\n    expSelectMove(): number {\r\n        var bestMove: number = undefined;\r\n        var bestMoveScore: number = -Infinity;\r\n        for (const [move, child] of this.getMoveChildPairs()) {\r\n            if (!child) {\r\n                continue;\r\n            }\r\n\r\n            const score = (child.wins / child.n);\r\n            if (score > bestMoveScore) {\r\n                bestMove = move;\r\n                bestMoveScore = score;\r\n            }\r\n        }\r\n\r\n        return bestMove;\r\n    }\r\n\r\n    _search(game: ConnectFourGame, targetState: 'PLAYER_1_WIN' | 'PLAYER_2_WIN'): 'PLAYER_1_WIN' | 'PLAYER_2_WIN' | 'DRAW' {\r\n        this.n += 1\r\n        if (game.isOver()) {\r\n            if (game.gameState === targetState) {\r\n                this.wins += 1;\r\n            }\r\n            return game.gameState as 'PLAYER_1_WIN' | 'PLAYER_2_WIN' | 'DRAW';\r\n        }\r\n\r\n        const selectedMove = this.ucbSelectMove();\r\n        var child = this.moveToChildMap[selectedMove];\r\n        // If child is undefeined\r\n        if (!child) {\r\n            // Compute required info\r\n            const childTargetState = findCurrentTargetState(game);\r\n            game.push(selectedMove);\r\n            const childValidMoves = game.validMoves();\r\n            game.pop();\r\n\r\n            // Create child\r\n            child = new MCTSNode(childValidMoves, selectedMove);\r\n            this.moveToChildMap[selectedMove] = child;\r\n\r\n            // Do random playthrough\r\n            game.push(selectedMove);\r\n            const randomPlaythroughResult = randomPlaythrough(game);\r\n            game.pop();\r\n\r\n            // Update model\r\n            child.n += 1;\r\n            if (randomPlaythroughResult === childTargetState) {\r\n                child.wins += 1;\r\n            }\r\n\r\n            if (randomPlaythroughResult === targetState) {\r\n                this.wins += 1;\r\n            }\r\n\r\n            return randomPlaythroughResult;\r\n\r\n        } else {\r\n            const result = child.search(game);\r\n            if (result === targetState) {\r\n                this.wins += 1;\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n}\r\n\r\nonmessage = function (msg: MessageEvent) {\r\n    const game = new ConnectFourGame();\r\n    game.board = msg.data.board;\r\n    game.gameState = msg.data.gameState;\r\n    game.moveHistory = msg.data.moveHistory;\r\n    game.gameStateHistory = msg.data.gameStateHistory;\r\n\r\n    const mcts = new MCTS(game);\r\n    const bestMove = mcts.search();\r\n\r\n    postMessage(bestMove);\r\n}\r\n\r\n\r\n"],"names":["$d52a1247a0013b6f5678ce6e6d8176ef$export$8c16bd5092a9ceb5","COLUMNS","ROWS","ALL_COLUMNS_INDICES","ALL_ROW_INDICES","TURN_TO_TILE_MAP","$d52a1247a0013b6f5678ce6e6d8176ef$export$6074c9b09a3f9ed8","board","gameState","moveHistory","gameStateHistory","[object Object]","this","column","filter","moveIsValid","length","previousGameState","player","isOver","Error","rowToFill","Math","min","row","updatedGameState","_calculateUpdatedGameState","push","pop","rowToClear","max","changedRow","changedColumn","findFourInARow","tiles","consecutiveTile","consecutiveCount","i","columnFourInARow","map","rowFourInARow","delta","columnIndex","rowIndex","upRightDiagonalTiles","upDiagonalFourInARow","upLeftDiagonalTiles","upLeftDiagonalFourInARow","validMoves","$df85f10d7a3b3926f074748bad5d2f89$var$MCTS","game1","game","root","$df85f10d7a3b3926f074748bad5d2f89$var$MCTSNode","undefined","totalIterations","start","performance","now","_search","$df85f10d7a3b3926f074748bad5d2f89$var$findCurrentTargetState","console","log","expSelectMove","move","wins","n","moveToChildMap","targetState","searchResult","move1","c","sqrt","bestMove","bestMoveScore","Infinity","child","getMoveChildPairs","score","selectedMove","ucbSelectMove","result","search","childTargetState","childValidMoves","randomPlaythroughResult","moveCount","randomMove","floor","random","$df85f10d7a3b3926f074748bad5d2f89$var$randomPlaythrough","onmessage","msg","game2","data","postMessage"],"version":3,"file":"ai_worker.9e970cef.js.map"}