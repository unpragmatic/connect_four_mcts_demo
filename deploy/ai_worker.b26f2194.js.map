{"version":3,"sources":["src/connect_four.ts","src/ai_worker.ts"],"names":[],"mappings":"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","file":"ai_worker.b26f2194.js","sourceRoot":"..","sourcesContent":["import { number } from \"prop-types\";\r\n\r\nexport type Tile = 'EMPTY' | 'PLAYER_1' | 'PLAYER_2';\r\nexport type GameState = 'PLAYER_1_TURN' | 'PLAYER_2_TURN' | 'PLAYER_1_WIN' | 'PLAYER_2_WIN' | 'DRAW';\r\n\r\nexport const Constants = {\r\n    COLUMNS: 7,\r\n    ROWS: 6,\r\n    ALL_COLUMNS_INDICES: [0, 1, 2, 3, 4, 5, 6],\r\n    ALL_ROW_INDICES: [0, 1, 2, 3, 4, 5],\r\n    TURN_TO_TILE_MAP: {\r\n        'PLAYER_1_TURN': 'PLAYER_1',\r\n        'PLAYER_2_TURN': 'PLAYER_2'\r\n    }\r\n}\r\n\r\nexport class ConnectFourGame {\r\n    board: Tile[][];\r\n    gameState: GameState;\r\n    moveHistory: number[];\r\n    gameStateHistory: GameState[];\r\n\r\n    constructor() {\r\n        this.board = [\r\n            ['EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY'],\r\n            ['EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY'],\r\n            ['EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY'],\r\n            ['EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY'],\r\n            ['EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY'],\r\n            ['EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY', 'EMPTY'],\r\n        ];\r\n        this.gameState = 'PLAYER_1_TURN';\r\n        this.moveHistory = [];\r\n        this.gameStateHistory = ['PLAYER_1_TURN'];\r\n    }\r\n\r\n    isOver() {\r\n        return this.gameState != 'PLAYER_1_TURN' && this.gameState != 'PLAYER_2_TURN';\r\n    }\r\n\r\n    moveIsValid(column: number) {\r\n        return this.board[Constants.ROWS - 1][column] == 'EMPTY';\r\n    }\r\n\r\n    validMoves() {\r\n        return Constants.ALL_COLUMNS_INDICES.filter(column => this.moveIsValid(column));\r\n    }\r\n\r\n    currentPlayer(): 'PLAYER_1' | 'PLAYER_2' {\r\n        if (this.gameStateHistory.length === 1) {\r\n            return 'PLAYER_1';\r\n        }\r\n        \r\n        const previousGameState = this.gameStateHistory[this.gameState.length - 2];\r\n        if (previousGameState === 'PLAYER_1_TURN') {\r\n            return 'PLAYER_2';\r\n        } else if (previousGameState === 'PLAYER_2_TURN') {\r\n            return 'PLAYER_1';\r\n        }\r\n    }\r\n\r\n    playerHasWon(player: 'PLAYER_1' | 'PLAYER_2') {\r\n        if (this.gameState === 'PLAYER_1_WIN' && player === 'PLAYER_1') {\r\n            return true;\r\n        } else if (this.gameState === 'PLAYER_2_WIN' && player === 'PLAYER_2') {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    push(column: number) {\r\n        if (this.isOver()) {\r\n            throw new Error(\"Invalid move. Game is already over.\");\r\n        }\r\n\r\n\r\n        if (!this.moveIsValid(column)) {\r\n            throw new Error(\"Invalid move. Column is filled.\");\r\n        }\r\n\r\n        const rowToFill = Math.min(...Constants.ALL_ROW_INDICES.filter(row => this.board[row][column] == 'EMPTY'));\r\n\r\n        this.board[rowToFill][column] = Constants.TURN_TO_TILE_MAP[this.gameState];\r\n\r\n        const updatedGameState = this._calculateUpdatedGameState(rowToFill, column);\r\n        this.gameState = updatedGameState;\r\n\r\n        this.moveHistory.push(column);\r\n        this.gameStateHistory.push(updatedGameState);\r\n    }\r\n\r\n    pop() {\r\n        if (this.moveHistory.length === 0) {\r\n            throw new Error(\"Can't undo. No move to undo.\");\r\n        }\r\n\r\n        const column = this.moveHistory.pop();\r\n        this.gameStateHistory.pop();\r\n        const previousGameState = this.gameStateHistory[this.gameStateHistory.length - 1];\r\n        \r\n        const rowToClear = Math.max(...Constants.ALL_ROW_INDICES.filter(row => this.board[row][column] != 'EMPTY'));\r\n\r\n        this.board[rowToClear][column] = 'EMPTY';\r\n        this.gameState = previousGameState;\r\n    }\r\n\r\n    _calculateUpdatedGameState(changedRow: number, changedColumn: number): GameState {\r\n        //  Check column for victory\r\n        const findFourInARow = (tiles: Tile[]): undefined | 'PLAYER_1_WIN' | 'PLAYER_2_WIN' => {\r\n            var consecutiveTile: Tile = 'EMPTY';\r\n            var consecutiveCount = 0;\r\n            for (var i = 0; i < tiles.length; i++) {\r\n                if (tiles[i] === consecutiveTile) {\r\n                    consecutiveCount += 1;\r\n                } else {\r\n                    consecutiveTile = tiles[i];\r\n                    consecutiveCount = 1;\r\n                }\r\n\r\n                if (consecutiveCount === 4 && consecutiveTile !== 'EMPTY') {\r\n                    if (consecutiveTile === 'PLAYER_1') {\r\n                        return 'PLAYER_1_WIN';\r\n                    } else {\r\n                        return 'PLAYER_2_WIN';\r\n                    }\r\n                }\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        const columnTiles = Constants.ALL_ROW_INDICES.map(row => this.board[row][changedColumn]);\r\n        const columnFourInARow = findFourInARow(columnTiles);\r\n        if (columnFourInARow) {\r\n            return columnFourInARow;\r\n        }\r\n\r\n        const rowTiles = Constants.ALL_COLUMNS_INDICES.map(column => this.board[changedRow][column]);\r\n        const rowFourInARow = findFourInARow(rowTiles);\r\n        if (rowFourInARow) {\r\n            return rowFourInARow;\r\n        }\r\n\r\n        // Up-right diagonal\r\n        var delta = Math.min(changedRow, changedColumn);\r\n        var columnIndex = changedColumn - delta;\r\n        var rowIndex = changedRow - delta;\r\n        const upRightDiagonalTiles = [];\r\n        while (columnIndex < Constants.COLUMNS && rowIndex < Constants.ROWS) {\r\n            upRightDiagonalTiles.push(this.board[rowIndex][columnIndex]);\r\n            columnIndex += 1;\r\n            rowIndex += 1;\r\n        }\r\n        const upDiagonalFourInARow = findFourInARow(upRightDiagonalTiles);\r\n        if (upDiagonalFourInARow) {\r\n            return upDiagonalFourInARow;\r\n        }\r\n\r\n        // # Up-left\r\n        delta = Math.min(Constants.COLUMNS - changedColumn, changedRow);\r\n        columnIndex = changedColumn + delta;\r\n        rowIndex = changedRow - delta;\r\n        const upLeftDiagonalTiles = []\r\n        while (columnIndex >= 0 && rowIndex < Constants.ROWS) {\r\n            upLeftDiagonalTiles.push(this.board[rowIndex][columnIndex]);\r\n            columnIndex -= 1;\r\n            rowIndex += 1;\r\n        }\r\n        const upLeftDiagonalFourInARow = findFourInARow(upLeftDiagonalTiles);\r\n        if (upLeftDiagonalFourInARow) {\r\n            return upLeftDiagonalFourInARow;\r\n        }\r\n\r\n        if (this.validMoves().length == 0) {\r\n            return 'DRAW';\r\n        }\r\n\r\n        if (this.gameState === 'PLAYER_1_TURN') {\r\n            return 'PLAYER_2_TURN';\r\n        } else {\r\n            return 'PLAYER_1_TURN';\r\n        }\r\n    }\r\n}","import { ConnectFourGame, Constants } from \"./connect_four\";\r\n\r\nclass MCTS {\r\n    game: ConnectFourGame\r\n    root: MCTSNode\r\n\r\n    constructor(game: ConnectFourGame) {\r\n        this.game = game;\r\n        this.root = new MCTSNode(game.validMoves(), undefined);\r\n    }\r\n\r\n    search(): number | undefined {\r\n        if (this.game.isOver()) {\r\n            return undefined;\r\n        }\r\n\r\n        var totalIterations = 0;\r\n        const start = performance.now();\r\n        const computationTime = 1 * 1000; // 1 second\r\n        while (performance.now() - start < computationTime) {\r\n            for (var i = 0; i < 2000; i++) {\r\n                this.root._search(this.game, findCurrentTargetState(this.game));\r\n            }\r\n            totalIterations += 2000;\r\n        }\r\n\r\n        console.log(totalIterations)\r\n        return this.root.expSelectMove();\r\n    }\r\n}\r\n\r\nfunction findCurrentTargetState(game: ConnectFourGame): 'PLAYER_1_WIN' | 'PLAYER_2_WIN' {\r\n    if (game.gameState === 'PLAYER_1_TURN') {\r\n        return 'PLAYER_1_WIN';\r\n    } else if (game.gameState === 'PLAYER_2_TURN') {\r\n        return 'PLAYER_2_WIN';\r\n    } else {\r\n        throw new Error('Unexpected conditions');\r\n    }\r\n}\r\n\r\nfunction randomPlaythrough(game: ConnectFourGame): 'PLAYER_1_WIN' | 'PLAYER_2_WIN' | 'DRAW' {\r\n    var moveCount = 0;\r\n    while (!game.isOver()) {\r\n        const validMoves = game.validMoves();\r\n        const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];\r\n        game.push(randomMove);\r\n        moveCount += 1;\r\n    }\r\n\r\n    const result = game.gameState as 'PLAYER_1_WIN' | 'PLAYER_2_WIN' | 'DRAW';\r\n    for (var i = 0; i < moveCount; i++) {\r\n        game.pop();\r\n    }\r\n    return result;\r\n}\r\n\r\nclass MCTSNode {\r\n    move: number\r\n    wins: number\r\n    n: number\r\n    validMoves: number[]\r\n    moveToChildMap: MCTSNode[]\r\n\r\n    constructor(validMoves: number[], move: number) {\r\n        this.move = move;\r\n        this.wins = 0;\r\n        this.n = 0;\r\n        this.validMoves = validMoves;\r\n        this.moveToChildMap = [];\r\n    }\r\n\r\n    search(game: ConnectFourGame): 'PLAYER_1_WIN' | 'PLAYER_2_WIN' | 'DRAW' {\r\n        const targetState = findCurrentTargetState(game);\r\n\r\n        game.push(this.move);\r\n        const searchResult = this._search(game, targetState);\r\n        game.pop();\r\n\r\n        return searchResult;\r\n    }\r\n\r\n    getMoveChildPairs(): [number, MCTSNode | undefined][] {\r\n        return this.validMoves.map(move => [move, this.moveToChildMap[move]]);\r\n    }\r\n\r\n    ucbSelectMove(): number {\r\n        const c = Math.sqrt(2);\r\n        var bestMove: number = undefined;\r\n        var bestMoveScore: number = -Infinity;\r\n        for (const [move, child] of this.getMoveChildPairs()) {\r\n            if (!child) {\r\n                return move;\r\n            }\r\n            const score = (child.wins / child.n) + c * Math.sqrt(Math.log(this.n) / child.n);\r\n            if (score > bestMoveScore) {\r\n                bestMove = move;\r\n                bestMoveScore = score;\r\n            }\r\n        }\r\n\r\n        return bestMove;\r\n    }\r\n\r\n    expSelectMove(): number {\r\n        var bestMove: number = undefined;\r\n        var bestMoveScore: number = -Infinity;\r\n        for (const [move, child] of this.getMoveChildPairs()) {\r\n            if (!child) {\r\n                continue;\r\n            }\r\n\r\n            const score = (child.wins / child.n);\r\n            if (score > bestMoveScore) {\r\n                bestMove = move;\r\n                bestMoveScore = score;\r\n            }\r\n        }\r\n\r\n        return bestMove;\r\n    }\r\n\r\n    _search(game: ConnectFourGame, targetState: 'PLAYER_1_WIN' | 'PLAYER_2_WIN'): 'PLAYER_1_WIN' | 'PLAYER_2_WIN' | 'DRAW' {\r\n        this.n += 1\r\n        if (game.isOver()) {\r\n            if (game.gameState === targetState) {\r\n                this.wins += 1;\r\n            }\r\n            return game.gameState as 'PLAYER_1_WIN' | 'PLAYER_2_WIN' | 'DRAW';\r\n        }\r\n\r\n        const selectedMove = this.ucbSelectMove();\r\n        var child = this.moveToChildMap[selectedMove];\r\n        // If child is undefeined\r\n        if (!child) {\r\n            // Compute required info\r\n            const childTargetState = findCurrentTargetState(game);\r\n            game.push(selectedMove);\r\n            const childValidMoves = game.validMoves();\r\n            game.pop();\r\n\r\n            // Create child\r\n            child = new MCTSNode(childValidMoves, selectedMove);\r\n            this.moveToChildMap[selectedMove] = child;\r\n\r\n            // Do random playthrough\r\n            game.push(selectedMove);\r\n            const randomPlaythroughResult = randomPlaythrough(game);\r\n            game.pop();\r\n\r\n            // Update model\r\n            child.n += 1;\r\n            if (randomPlaythroughResult === childTargetState) {\r\n                child.wins += 1;\r\n            }\r\n\r\n            if (randomPlaythroughResult === targetState) {\r\n                this.wins += 1;\r\n            }\r\n\r\n            return randomPlaythroughResult;\r\n\r\n        } else {\r\n            const result = child.search(game);\r\n            if (result === targetState) {\r\n                this.wins += 1;\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n}\r\n\r\nonmessage = function (msg: MessageEvent) {\r\n    const game = new ConnectFourGame();\r\n    game.board = msg.data.board;\r\n    game.gameState = msg.data.gameState;\r\n    game.moveHistory = msg.data.moveHistory;\r\n    game.gameStateHistory = msg.data.gameStateHistory;\r\n\r\n    const mcts = new MCTS(game);\r\n    const bestMove = mcts.search();\r\n\r\n    postMessage(bestMove);\r\n}\r\n\r\n\r\n"]}